# thread vs event

---

讲的是如何处理大量并发连接。

主要的难题是如何处理大量的 IO 操作。
多线程的方式，性能受上下切换、内存使用等限制；
事件驱动的方式，打乱了处理顺序，不如其他方式易读，也没有有效利用多核

---

http://berb.github.io/diploma-thesis/community/042_serverarch.html

---

## thread

优点
+ 直观，进程内是完整、顺序的逻辑
+ 能直接利用多核性能

缺点
+ 不管是进程还是线程，内存需求都不小。
    高连接数意味着大量内存需求，减少连接数意味着处理能力下降。
+ 进程切换有上下文切换的开销，造成 CPU 缓存的命中率下降

---

## event







---

### reactor pattern

- synchronous non-blocking IO
- 有一个核心的事件分发机制，比如 epoll
- 提供的事件机制解耦了事件分发和应用层的代码
- 在单进程时，需要需要注意应用层代码不要出现阻塞。阻塞会影响整个 event loop

### proactor pattern

- asynchronous non-blocking IO
- reactor 提供了可读可写的事件，需要自己持续读写。
    proactor 提供的是完成事件，可以直接获取需要的数据。
- 比 reactor 更适合多进程处理，事件处理可以直接丢到其他进程去。

---





