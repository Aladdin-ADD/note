# thread vs event

---

讲的是如何处理大量并发连接。

主要的难题是如何处理大量的 IO 操作。
多线程的方式，性能受上下切换、内存使用等限制；
事件驱动的方式，打乱了处理顺序，不如其他方式易读，也没有有效利用多核

---

http://berb.github.io/diploma-thesis/community/042_serverarch.html

---

## thread

优点
+ 直观，进程内是完整、顺序的逻辑
+ 能直接利用多核性能

缺点
+ 不管是进程还是线程，内存需求都不小。
    高连接数意味着大量内存需求，减少连接数意味着处理能力下降。
+ 进程切换有上下文切换的开销，造成 CPU 缓存的命中率下降

---

## event







---

### reactor pattern

- synchronous non-blocking IO
- 有一个核心的事件分发机制，比如 epoll
- 提供的事件机制解耦了事件分发和应用层的代码
- 在单进程时，需要需要注意应用层代码不要出现阻塞。阻塞会影响整个 event loop

### proactor pattern

- asynchronous non-blocking IO
- reactor 提供了可读可写的事件，需要自己持续读写。
    proactor 提供的是完成事件，可以直接获取需要的数据。
- 比 reactor 更适合多进程处理，事件处理可以直接丢到其他进程去。

---




http://berb.github.io/diploma-thesis/community/043_threadsevents.html

---

基于事件和基于进程，从能力上来说，是等价的。


## thread

+ 将调度交给系统，同步阻塞的程序流程很自然
+ 真正的并行代码，最底层肯定依赖于进程
+ 其他模型也需要在底层对进程模型进行封装
+ 编写能正确的并行代码并不简单
+ 进程间的同步需要借助锁，可能出现死锁等情况
+ 锁的粒度不好控制，太大影响并行，太小容易造成死锁
+ 难以调试
+ 大量进程意味着频繁的上下文切换，本身就影响性能

## event

+ 单进程事件循环的方式，就足以带来 IO 并行，不需要 CPU 也并行
+ 事件和回调的方式，使得完整的过程变得散乱
+ （getify 谈论 promise 时，也说到使用回调时出现了 IOC
+ 回调的状态需要手动维护，如果不支持闭包等特性，实现会很麻烦
+ 需要回调主动交出控制权
+ 难以利用多核












