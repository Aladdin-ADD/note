# sicp

---

第一章主要讲的是对函数的组合。

印象比较深的是 递归 与 迭代。
以前看过 guido 关于为什么 python 不会支持尾递归的文章，里面提到很重要一点就是所有尾递归都能改写成迭代的形式。
实际看 sicp 中例子，能感觉到尾递归和迭代确实只是两种不同的表达形式，而且将函数改造成 迭代函数 也不比改造成 循环迭代 来得简单。
但是尾调用又不太一样，尾递归能简单改成迭代，尾调用改起来稍微麻烦些。
不过 guido 提出的反对意见也很有说服力，如果对尾调用进行优化，意味着不保存调用栈，会给调试带来麻烦。

关于递归和迭代的实现，我的理解是一次调用过程中，包含了完整环境变量。
这又让我想到了 函数式编程 和 闭包 这两个概念，可能还要加上 monad，这里不扯太远了。

---

看到 3.1，里面提到了迭代函数和循环迭代。循环迭代需要引入 赋值 这个操作。
而赋值在很多时候，会破坏纯函数的特性。

---

第三章介绍了两种组织程序的方式， 对象（object-based） 和 流（stream-processing）。

---

基于对象的方式引入了赋值的概念，这使得模块之间可以完全隔离，上层不需要知道下层的具体实现。
模块可以靠赋值改版自己的环境变量。
如果没有赋值的能力，在调用其他模块时，调用者就要传入完整的环境变量。

引入赋值的代价是函数不能再随意组合，执行结果和调用顺序是有关的。
我自己这里的表述不是非常严谨，赋值不是打破纯函数的特性（即执行结果和调用顺序无关）的充分条件。

imperative 和 functional

---

又看了下 haskell 的简单介绍，突然意识到，haskell 的延迟求值策略，其实就上 sicp 提到的 stream 模型。

---

又看了下 haskell 的简单介绍，突然意识到，haskell 的延迟求值策略，其实就上 sicp 提到的 stream 模型。

---

又看了下 haskell 的简单介绍，突然意识到，haskell 的延迟求值策略，其实就上 sicp 提到的 stream 模型。

---

2.1 中的结构模型：
1. 应用代码。应用层或者业务层的代码。
2. 对外 API。这层 API 不需要了解数据的实际结构，只是调用下一层 API 达到修改数据的目的。
3. 结构 API。只有组合和获取两种功能，用于将基础数据组合成复杂数据，并从复杂数据中获取基础数据。
4. 底层设施。语言层面提供的基础设施。
