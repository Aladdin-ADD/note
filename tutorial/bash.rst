折行
=====
使用 ``\`` 来折行。

.. code::

    $ ls \
    > -a


变量作用域
===========
默认是全局变量，也可以声明为局部变量。

.. code:: bash

    global1=1 # 全局变量

    func() {
        global2=2 # 全局变量
        local local1=1 # 局部变量
        declare local2=2 # 局部变量
    }




修改环境变量
=============

.. code::

    $ cat example.sh
    #!/usr/bin/env bash
    var=10
    export var

    $ chmod u+x example.sh
    $ ./example.sh
    $ echo $var
    (nil)

    $ . ./example.sh
    $ echo $var
    10

    $ source example.sh
    $ echo $var
    10

直接执行脚本，会把变量导出到一个新的 shell 中。
要修改当前的环境变量，要使用 ``source`` 或者 ``.`` ，
都是 shell 的内置命令，用来在当前的 shell 之执行脚本的内容。





参数
=====

+----------------+----------------------------------------------+
| 参数           | 描述                                         |
+================+==============================================+
| $0             | 执行的脚本的名称，在哪都是脚本名             |
+----------------+----------------------------------------------+
| $FUNCNAME      | 执行的函数的名称，在函数外是空值             |
+----------------+----------------------------------------------+
| $1, ${10}, ... | 脚本或者函数的参数，在函数中和函数外是不同的 |
+----------------+----------------------------------------------+
| $#             | 参数的个数                                   |
+----------------+----------------------------------------------+
| $*, $@         | 参数的数组，照数组理解就好                   |
+----------------+----------------------------------------------+

**注意** 上面提到的参数都是不包含 ``$0`` 和 ``$FUNCNAME`` 的，
这两个都是特殊的。

``$*`` 和 ``$@`` 只在使用引号的时候才有区别，这点和数组也是一样的。
``$*`` 是一个字符串，其中的 ``c`` 是 ``IFS`` 的第一个字符。
而 ``$@`` 是每个参数对应的字符串。

+------+----------------------+
| $*   | $1 $2 ... ${N}       |
+------+----------------------+
| $@   | $1 $2 ... ${N}       |
+------+----------------------+
| "$*" | "$1c$2c...c${N}"     |
+------+----------------------+
| "$@" | "$1" "$2" ... "${N}" |
+------+----------------------+

另外， ``shift`` 命令可以用来移动参数。
