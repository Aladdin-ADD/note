luagit gc
==========
+ http://wiki.luajit.org/New-Garbage-Collector

垃圾回收大致分为两个阶段：

1. 标记（mark）阶段，标记所有有效对象，没有标记的都是无效对象。
2. 清除（sweep）阶段，释放所有无效对象。


二色标记清除（two-color mark & sweep）
---------------------------------------
+ 新对象标记为白色。
+ 标记阶段，所有可用对象标记为黑色。
+ 清除阶段，先释放白色（不可用）对象，再将所有对象标记为白色。

+ 缺点是执行线程和回收线程不能交叉执行。
+ 原子型回收（atomic collection），非增量（non-incremental）。

+ 优化：每经过一次循环，交换黑白的含义，
  省去清除阶段把所有对象标记为白色的开销。

+ 实现：lua5.0 中，使用链表来保存对象。



三色增量标记清除（tri-color incremental mark & sweep）
-------------------------------------------------------
+ 新对象标记为白色。
+ 标记阶段，将可用对象标记为灰色。
  对于所有灰色对象，先标记其能接触到的对象，在转换为黑色。
+ 清除阶段，先释放白色（不可用）对象，再将所有对象标记为白色。

+ 属于增量（incremental）回收。
  回收线程可以处理部分对象后，让执行线程先执行，之后再继续处理剩下的对象。
  这点对于交互应用非常重要。
+ 交错执行也会带来问题：可能出现对象在标记阶段被标记为白色，
  然后被其他对象引用，然后这个对象在清除阶段被释放。
+ 一种解决方案是：不在黑色（可用）对象中引用白色（不可用）对象。
  在每次写入时，进行相应的检查。

优化方案：

+ 对象没有对其他对象的引用，直接从白色标记为黑色而不是灰色。




分代回收（generational gc）
----------------------------
+ 每代回收线程使用独立的内存空间。（典型的是三代。）
+ 新对象放在最新的回收线程中。
+ 用复制（copy）阶段代替清除阶段。
  可用对象复制到下一代回收线程里，剩下的不可用对象直接清除。
+ 在最后一代回收线程里，使用通常的标记清楚算法回收空间。

注：上面的线程不是指和进程对应的那个线程（thread），只是我自己给个称呼。

+ 最后一代回收线程称为主回收线程（major collection），
  其余称为次回收线程（minor collection）。
+ 次回收线程只关心新对象。
+ 主回收线程处理全部对象，但是运行频率要比次回收线程低。
+ 次回收线程在执行时。
  清除阶段，释放白色（不可用）对象，但是不改变对象的颜色。
  标记阶段，只遍历新对象和有写入的对象，其他对象都直接假设为可用的。
