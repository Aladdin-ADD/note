+ https://github.com/kriskowal/q/blob/master/design/README.js



从更抽象的角度来讲，promise 类似于计算的结果，
感觉就像是 CPS 中的 continuation。

从实现的角度，promise 是有 ``then`` 方法的对象。
这个可以去翻 http://promisesaplus.com/ ，
不过 promises/a+ 规范超出这篇文章了。

最粗略的实现，可以看 ``q0.js`` 。
deferred 有两个方法， ``then`` 注册回调函数， ``resolve`` 会调用这些函数。
如果 ``then`` 是在 ``resolve`` 之后调用的，会直接执行要注册的回调函数。

-------------------------------------------------------------------------------

在 promises/a+ 规定，
promise 只能从 ``pending`` 状态转换到 ``fulfilled`` 或 ``rejected`` ，
之后就不能继续转换状态了。

所以在 ``q1.js`` 的实现中， ``resolve`` 只能调用一次。
从结果来讲，也就是注册的回调函数只会被调用一次。

为什么这么设计呢？

文中是这么解释的：
按照正常的流程，先是调用函数，然后函数返回结果或者抛出错误。
函数不会返回多次，也不会出现先返回一个结果，再抛出一个错误之类的情况。
既然 promise 是函数结果的抽象，那么 promise 也应该满足这种特点。
promise 从 ``pending`` 出发，发生状态转移，
对应于函数返回（ ``fulfilled`` ）或抛出错误（ ``rejected`` ）。
状态转移之后，相当于函数执行完了，既然函数不会返回多次，
promise 的状态也就不应该再改变了。

-------------------------------------------------------------------------------

``q2.js`` 和 ``q3.js`` 演示了如何将 promise 和 ``resolve`` 分离开来。
``q2.js`` 使用继承，靠 ``instanceof`` 判断；
``q3.js`` 检查 ``then`` 方法，也就是所谓的鸭子类型（duck-typing）。

那么，为什么要分离呢？主要是为了权限控制。

``resolve`` 只能决定解析状态， promise 只能获取解析状态。
将两种权限分离开来。（分开到底有什么好处？）

后面的实现里使用 ``q3.js`` 的方法，主要是为了兼容 promises/a+ 的不同实现。

-------------------------------------------------------------------------------

promises/a+ 规定，promise.then 必须返回一个 promise。

实现这一特性后，我们就能够将 promise 组合起来。

``q4.js`` 里，为了实现这个特性，代码一下子变乱了。

-------------------------------------------------------------------------------

前面都是在处理函数正常返回的情况，我们还要处理函数抛出错误的情况。

``q5.js`` 和 ``q6.js`` 添加了对 ``rejected`` 的支持。

其实也没有什么特别的地方，就是是实现了一个 ``reject`` 方法，
该方法返回的 promise 在调用 ``then`` 时，
会执行 ``errback`` 而不是 ``callback`` 。

-------------------------------------------------------------------------------

``q7.js`` 的着眼点是执行顺序，
保证回调函数的执行顺序和注册顺序相同。

就具体实现来说，也很简单。
不直接执行回调函数，而是将回调函数依次加入执行队列。
这就保证了回调函数执行的顺序是严格按照注册顺序进行的。
