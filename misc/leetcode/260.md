# 260. Single Number III

---

```js
var singleNumber = function(nums) {
	var map = {};
	for (var i = 0, ii = nums.length; i < ii; i++) {
		var n = nums[i];
		if (map[n]) {
			map[n] = false;
		} else {
			map[n] = true;
		}
	}
	var arr = [];
	for (var k in map) {
		if (map[k]) arr.push(Number(k));
	}
	return arr;
};
```

用 map 可以解决问题。
但是空间复杂度怎么达到要求想不出来……

---

看了下 tag，又是 bit，上次那题 xor 是很神啦，这里要怎么用呢…… 
题目特意提到，重复的都是重复两次，只有两个不重复，知道这些是关键，但是怎么用起来……
翻了下之前的记录，上次的题目是 single number I 吧，还是不会，真是一点长进都没有……

---

看讨论啦啦啦。

第一点，是要把 A B 划分到不同的组里，其他数字，相同的分到一组就行。
这样问题就退化成了之前的问题。

如何完成这种分组。先全部数字 XOR 一次得到 C=A^B。
因为 A B 是不同的数字，所以 C 中有 bit 为 1 的位，
假设为第 x 位，即 Ax=1 Bx=0 或者反过来，无所谓。
所有数字，靠第 x 位为 0 还是 1 可以划分成我们需要的两组。

如果有一个第 x 位为 1，其他位为 0 的数 D，我们就可以用 A^D>0 B^D=0 来分组。
然后这个 D，可以 C&-C 得到。

尼玛这完全不是解题思路，是在强行套答案啊……

```c
int* singleNumber(int* nums, int numsSize, int* returnSize) {
	int C = 0;
	for (int i = 0; i < numsSize; i++) {
		C ^= nums[i];
	}

	int D = C&(-C);

	int A = 0;
	int B = 0;

	for (int i = 0; i < numsSize; i++) {
		if ((D & nums[i]) == 0) {
			B ^= nums[i];
		} else {
			A ^= nums[i];
		}
	}

	// 下面都没啥用，到这 A B 就都出来了

	*returnSize = 2;
	int *arr = malloc(sizeof(int) * 2);
	arr[0] = A;
	arr[1] = B;

	return arr;
}
```
