# 189. Rotate Array

---

```c
// timeout
void rotate(int* nums, int numsSize, int k) {
	if (numsSize == 0) return;
	if (k >= numsSize) k %= numsSize;
	if (k == 0) return;
	while (k-- != 0) {
		int tmp = nums[numsSize - 1];
		int i = numsSize;
		while (--i) {
			nums[i] = nums[i - 1];
		}
		nums[0] = tmp;
	}
}
```

脑子想不清楚边界情况了，暴力算。
然后理所当然的 timeout 了……

---

```c
// wrong
void rotate(int* nums, int numsSize, int k) {
	if (numsSize == 0) return;
	if (k >= numsSize) k %= numsSize;
	if (k == 0) return;

	int x = 0;
	int val = nums[x];
	int val2 = nums[numsSize - k];
	do {
		int y = x + k;
		if (y >= numsSize) y = y - numsSize;
		int yVal = nums[y];
		nums[y] = val;
		val = yVal;
		x = y;
	} while (x != 0);
	nums[x] = val2;
}
```
错误认为 K STEP 往下遍历会全部替换一次，真是大失误……

---

```c
void rotate(int* nums, int numsSize, int k) {
	if (numsSize == 0) return;
	if (k >= numsSize) k %= numsSize;
	if (k == 0) return;

	int arr[numsSize];
	for (int i = 0; i < numsSize; i++) arr[i] = nums[i];
	for (int i = 0; i < numsSize; i++) nums[i] = arr[(numsSize - k + i) % numsSize];
}
```

到最后，还是只写出了暴力解法……

---

看了下讨论。

- 复制一个数组的方式，最简单的实现，但是空间 O(n) 的消耗显得大一些
- 分成两个数组分别倒序再整个数组倒序，真是好神奇
