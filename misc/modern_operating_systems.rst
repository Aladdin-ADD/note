2.1.5 进程状态
===============

运行态
    可以运行。在实际占用 CPU。

就绪态
    可以运行。在等待执行，此时 CPU 正在执行其他程序。

阻塞态
    无法运行。等待某种外部事件发生。





2.1.6
=======
系统维护着一张进程表（process table）。
表中的每个项都代表一个进程，保存着与进程相关的信息。


2.2.1
========

使用多线程的理由：

一，并行的实体间共享一个地址空间和所有可用数据的能力。
二，相比进程，线程在创建和撤销时的开销要小一些。
三，如果同时存在大量计算和大量 IO 处理，可以利用多线程来重叠执行。
四，多 CPU 系统中，可以进行真正的并行执行。

注意下，以上四点都是针对某种具体需求来说的。
如果不需要共享数据，那么一不成立；如果不需要频繁创建撤销，那么二不成立；
如果线程都是 CPU 密集型的，那么三不成立；
程序要针对多核进行优化，才会真正利用到多个 CPU。



2.2.4 用户级线程
=================

在用户空间实现线程。内核不知道线程的存在。

优点：

+ 可以在不支持线程的操作系统上实现。
+ 切换线程的速度快。相比进入内核空间，至少要快上一个数量级。
+ 可以针对不同程序使用不同的线程调度算法。

缺点：

+ 要实现阻塞的系统调用，比较麻烦。
+ 只要一个线程发生页面故障，就会影响整个进程。
+ 实际上只有一个线程在执行，且在线程交出控制权之前，无法中断。



2.2.5 内核级线程
=================

在内核中实现线程。

由于在内核中创建撤销线程的开销较大，一些系统在回收线程时，
只是把线程标记为不可用，并没有清除。
在需要创建新线程时，直接重用这些不可用的线程。
（用户级线程的创建开销较小，没必要使用这样的方式进行优化。）

基本上能解决用户级线程的所有问题，就是各种开销比较大。
另外，内核级线程也面临信号处理、创建子进程等问题。



2.2.6 混合线程
================

用户级线程和内核级线程的复用。两者的比例由编程人员决定。




2.4.2 批处理系统中的调度
=========================

+ 先来先服务 first-come first-serverd

    非抢占式。

+ 最短作业优先 shortest job first

    非抢占式。

    先执行所需时间最短的任务。适用于运行时间可以预知的情况。
    只有在所有作业都处在可执行状态下，这个调度算法才是最优化的。

+ 最短剩余时间优先 shortest remaining time next

    最短作业优先的抢占式版本。

    区别在于添加新任务时，可能会选择打断当前任务，执行新任务。



2.4.3 交互系统中的调度
=======================

+ 轮转调度 round robin

    给每个进程分配一个时间片（quantum），一旦超过时间，就将进程挂起。

    时间片分得太短，会导致频繁切换进程，降低 CPU 效率。
    时间片分得太长，会增加响应请求所需的时间。
    一般来说， 20-50 ms 是个合适的值。


+ 优先级调度

    给每个进程设置优先级，优先级最高的程序先运行。


+ 多级队列
+ 最短进程优先
+ 保证调度
+ 彩票调度
+ 公平分享调度
